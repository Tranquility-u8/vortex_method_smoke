// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Simulate

#define GROUP_SIZE_X 128

#include "ParticleCluster.cginc"
#include "ParticleHashGrid.cginc"
#include "VortexMethod.cginc"
#include "Grid.cginc"
#include "SDF.cginc"

_GRID_DEF_UNIFORM(Heat);
Texture3D<float> uHeatTexture;
SamplerState sampler_uHeatTexture;

_PHG_DEF_UNIFORM(Hash);
_PHG_DEF_BUFFER(Hash);

_VM_DEF_UNIFORM(VM);
_VM_DEF_FUNC(VM);

PC_DEF_UNIFORM
PC_DEF_BUFFER(TracerParticle)
PC_DEF_BUFFER_RW(TracerParticle)

_PC_DEF_UNIFORM(Vortex)
_PC_DEF_BUFFER(Vortex, VortexParticle)

_SDF_DEF_UNIFORM(SDF);
_SDF_DEF_TEXTURE(SDF);

float uDeltaTime;
float3 uInitialVelocity;

[numthreads(GROUP_SIZE_X, 1, 1)]
void Simulate(uint3 id : SV_DispatchThreadID) {
    uint src_idx = id.x;
    if (src_idx >= PC_COUNT)
        return;

    TracerParticle p = PC_GET(UNSAFE, src_idx);
    p.life -= uDeltaTime;

    float3 v = uInitialVelocity;
    uint s = _PC_IDX(Vortex, 0);
    #define REDUCER(P_ID) v += velocity_from_pos_vor(p.pos, pos_vor_from_vortex_particle(uVortexParticles[s + P_ID]));
    _PHG_REDUCE_NEIGHBOUR(Hash, p.pos, REDUCER);
    p.pos += v * uDeltaTime;

    // Check Collision
    _SDF_FIX_WORLD_POS(SDF, p.pos);

    if (p.life >= 0)
        PC_PUSH(SAFE, p);
}
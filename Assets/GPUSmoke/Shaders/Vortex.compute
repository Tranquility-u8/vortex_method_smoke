// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Simulate

#define GROUP_SIZE_X 128

#include "ParticleCluster.cginc"
#include "ParticleHashGrid.cginc"
#include "VortexMethod.cginc"
#include "Grid.cginc"
#include "SDF.cginc"

_GRID_DEF_UNIFORM(Heat);
Texture3D<float> uHeatTexture;
SamplerState sampler_uHeatTexture;

_PHG_DEF_UNIFORM(Hash);
_PHG_DEF_BUFFER(Hash);

_VM_DEF_UNIFORM(VM);
_VM_DEF_FUNC(VM);

PC_DEF_UNIFORM;
PC_DEF_BUFFER(VortexParticle);
PC_DEF_BUFFER_RW(VortexParticle);
    
_SDF_DEF_UNIFORM(SDF);
_SDF_DEF_TEXTURE(SDF);

float uDeltaTime;

float2 buoyancy_curl_xz_from_pos(in const float3 pos) {
    float3 uvw = _GRID_WORLD2UVW(Heat, pos);
    float2 uvw_dxz = _GRID_UNIT_CELL2UVW(Heat).xz;
    float world_d = _GRID_UNIT_CELL2WORLD(Heat);
    float d_fy_dz = (
            uHeatTexture.SampleLevel(sampler_uHeatTexture, float3(uvw[0], uvw[1], uvw[2] + uvw_dxz[1] * 0.5), 0) - 
            uHeatTexture.SampleLevel(sampler_uHeatTexture, float3(uvw[0], uvw[1], uvw[2] - uvw_dxz[1] * 0.5), 0)
        ) / world_d;
    float d_fy_dx = (
            uHeatTexture.SampleLevel(sampler_uHeatTexture, float3(uvw[0] + uvw_dxz[0] * 0.5, uvw[1], uvw[2]), 0) - 
            uHeatTexture.SampleLevel(sampler_uHeatTexture, float3(uvw[0] - uvw_dxz[0] * 0.5, uvw[1], uvw[2]), 0)
        ) / world_d;
    return float2(d_fy_dz, d_fy_dx) * _VM_HEAT_BUOYANCY_FACTOR(VM);
}

float buoyancy_velocity_from_pos(in const float3 pos) {
    float3 uvw = _GRID_WORLD2UVW(Heat, pos);
    return uHeatTexture.SampleLevel(sampler_uHeatTexture, uvw, 0) * _VM_HEAT_BUOYANCY_FACTOR(VM);
}

[numthreads(GROUP_SIZE_X, 1, 1)]
void Simulate(uint3 id : SV_DispatchThreadID) {
    uint src_idx = id.x;
    if (src_idx >= PC_COUNT)
        return;

    VortexParticle p = PC_GET(UNSAFE, __PHG_PARTICLE_IDS(Hash)[src_idx]); // Visit sorted particle to improve coherency
    p.life -= uDeltaTime;

    // Update Vortex
    float2 vor_dxz = buoyancy_curl_xz_from_pos(p.pos);
    p.vor.x += vor_dxz[0] * uDeltaTime;
    p.vor.z += vor_dxz[1] * uDeltaTime;

    // Update Position
    float3 v = float3(0, buoyancy_velocity_from_pos(p.pos), 0);
    uint s = PC_IDX(0);
    #define REDUCER(P_ID) v += velocity_from_pos_vor(p.pos, pos_vor_from_vortex_particle(uParticles[s + P_ID]));
    _PHG_REDUCE_NEIGHBOUR(Hash, p.pos, REDUCER);
    
    // Check Collision
    if (_SDF_SAMPLE(SDF, WORLD, p.pos) >= 0.0)
        p.pos += v * uDeltaTime;
    /* if (p.pos.y <= 10)
        v.y += buoyancy_velocity_from_pos(p.pos);
    p.pos += v * uDeltaTime;
    if (p.pos.y > 10)
        p.pos.y = 10 - abs(v.y) * uDeltaTime; */

    if (p.life >= 0)
        PC_PUSH(SAFE, p);
}